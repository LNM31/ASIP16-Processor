// =========================================================================
// TEST PROGRAM - Arithmetic, Logic, MOV, CMP (Opcodes 010100+)
// =========================================================================
// Testeaza doar instructiunile noi: ADD, SUB, MUL, DIV, MOD, AND, OR, XOR,
// NOT, shifts, CMP, TST, MOV
// Folosim LDA/STA pentru load/store (stim ca functioneaza)
// =========================================================================

// ==========================================================================
// SECTIUNEA 1: Test MOV Reg, #Imm (opcode 101101)
// ==========================================================================
B00A    // 0x00: MOV AC, #10        -> AC = 10 (0x000A)
1850    // 0x01: STA #50            -> Mem[50] = AC = 0x000A

B054    // 0x02: MOV X, #20         -> X = 20 (0x0014)
0C51    // 0x03: STR X, #51         -> Mem[51] = X = 0xFFF4

B09E    // 0x04: MOV Y, #30         -> Y = 30 (0x001E)
0E52    // 0x05: STR Y, #52         -> Mem[52] = Y = 0x001E

// ==========================================================================
// SECTIUNEA 2: Test MOV Reg, Reg (opcode 101100)
// ==========================================================================
B00F    // 0x06: MOV AC, #15        -> AC = 15
B420    // 0x07: MOV X, AC          -> X = AC = 15
0C53    // 0x08: STR X, #53         -> Mem[53] = X = 15

B441    // 0x09: MOV Y, X           -> Y = X = 15
0E54    // 0x0A: STR Y, #54         -> Mem[54] = Y = 15

// ==========================================================================
// SECTIUNEA 3: Test ADD/SUB (Reg) - opcode 010100, 010101
// ==========================================================================
B00A    // 0x0B: MOV AC, #10        -> AC = 10
B045    // 0x0C: MOV X, #5          -> X = 5

5000    // 0x0D: ADD AC, X          -> AC = AC + X = 10 + 5 = 15
1855    // 0x0E: STA #55            -> Mem[55] = 15

5400    // 0x0F: SUB AC, X          -> AC = AC - X = 15 - 5 = 10
1856    // 0x10: STA #56            -> Mem[56] = 10

// ==========================================================================
// SECTIUNEA 4: Test ADD/SUB (Imm) - M=1
// ==========================================================================
B00A    // 0x11: MOV AC, #10        -> AC = 10
5107    // 0x12: ADD AC, #7         -> AC = AC + 7 = 10 + 7 = 17
1857    // 0x13: STA #57            -> Mem[57] = 17

5503    // 0x14: SUB AC, #3         -> AC = AC - 3 = 17 - 3 = 14
1858    // 0x15: STA #58            -> Mem[58] = 14

// ==========================================================================
// SECTIUNEA 5: Test MUL/DIV/MOD - opcode 010110, 010111, 011000
// ==========================================================================
B005    // 0x16: MOV AC, #5         -> AC = 5
B043    // 0x17: MOV X, #3          -> X = 3

5A00    // 0x18: MUL AC, X          -> AC = AC * X = 5 * 3 = 15
1859    // 0x19: STA #59            -> Mem[59] = 15

B014    // 0x1A: MOV AC, #20        -> AC = 20
5E00    // 0x1B: DIV AC, X          -> AC = AC / X = 20 / 3 = 6
185A    // 0x1C: STA #5A            -> Mem[5A] = 6

6200    // 0x1D: MOD AC, X          -> AC = AC % X = 6 % 3 = 0
185B    // 0x1E: STA #5B            -> Mem[5B] = 0

// ==========================================================================
// SECTIUNEA 6: Test AND/OR/XOR - opcode 011001, 011010, 011011
// ==========================================================================
B00F    // 0x1F: MOV AC, #15        -> AC = 0x0F (00001111)
B047    // 0x20: MOV X, #7          -> X = 0x07 (00000111)

6600    // 0x21: AND AC, X          -> AC = AC & X = 0x0F & 0x07 = 0x07
185C    // 0x22: STA #5C            -> Mem[5C] = 0x07

B00F    // 0x23: MOV AC, #15        -> AC = 0x0F
6A00    // 0x24: OR AC, X           -> AC = AC | X = 0x0F | 0x07 = 0x0F
185D    // 0x25: STA #5D            -> Mem[5D] = 0x0F

B008    // 0x26: MOV AC, #8         -> AC = 0x08
6E00    // 0x27: XOR AC, X          -> AC = AC ^ X = 0x08 ^ 0x07 = 0x0F
185E    // 0x28: STA #5E            -> Mem[5E] = 0x0F

// ==========================================================================
// SECTIUNEA 7: Test NOT - opcode 011100
// ==========================================================================
B047    // 0x29: MOV X, #7          -> X = 0x07
7000    // 0x2A: NOT X              -> AC = ~X = ~0x07 = 0xFFF8
185F    // 0x2B: STA #5F            -> Mem[5F] = 0xFFF8

// ==========================================================================
// SECTIUNEA 8: Test LSR/LSL - opcode 100110, 100111
// ==========================================================================
B010    // 0x2C: MOV AC, #16        -> AC = 16 (0x10)
9801    // 0x2D: LSR #1             -> AC = AC >> 1 = 16 >> 1 = 8
1860    // 0x2E: STA #60            -> Mem[60] = 8

B004    // 0x2F: MOV AC, #4         -> AC = 4
9C02    // 0x30: LSL #2             -> AC = AC << 2 = 4 << 2 = 16
1861    // 0x31: STA #61            -> Mem[61] = 16

// ==========================================================================
// SECTIUNEA 9: Test RSR/RSL - opcode 101000, 101001
// ==========================================================================
B030    // 0x32: MOV AC, #30       -> AC = 0xFFF0 (110000)
A000    // 0x33: RSR                -> AC rotate right = 0x0050
1862    // 0x34: STA #62            -> Mem[62] = 0x50

B005    // 0x35: MOV AC, #5         -> AC = 0x0005 (00000101)
A400    // 0x36: RSL                -> AC rotate left = 0x000A
1863    // 0x37: STA #63            -> Mem[63] = 0x0A

// ==========================================================================
// SECTIUNEA 10: Test CMP - opcode 101010
// ==========================================================================
B00A    // 0x38: MOV AC, #10        -> AC = 10
B04A    // 0x39: MOV X, #10         -> X = 10
A801    // 0x3A: CMP AC, X          -> AC - X = 0, Z=1

2C3D    // 0x3B: BEQ 0x3D           -> Z=1, taken
B03F    // 0x3C: MOV AC, #3F       -> skip (not executed)

B001    // 0x3D: MOV AC, #1         -> AC = 1 (marker CMP==)
1864    // 0x3E: STA #64            -> Mem[64] = 1

// ==========================================================================
// SECTIUNEA 11: Test TST - opcode 101011
// ==========================================================================
B00F    // 0x3F: MOV AC, #15        -> AC = 0x0F
B047    // 0x40: MOV X, #7          -> X = 0x07
AC01    // 0x41: TST AC, X          -> AC & X = 0x07, Z=0

3044    // 0x42: BNE 0x44           -> Z=0, taken
B03F    // 0x43: MOV AC, #3F      -> skip (not executed)

B402    // 0x44: MOV AC, #2         -> AC = 2 (marker TST!=0)
1865    // 0x45: STA #65            -> Mem[65] = 2

// ==========================================================================
// SECTIUNEA 12: HLT
// ==========================================================================
0000    // 0x46: HLT                -> Stop

// ==========================================================================
// PADDING
// ==========================================================================
0000    // 0x47
0000    // 0x48
0000    // 0x49
0000    // 0x4A
0000    // 0x4B
0000    // 0x4C
0000    // 0x4D
0000    // 0x4E
0000    // 0x4F

// ==========================================================================
// DATA SECTION (0x50 - 0x65)
// ==========================================================================
0000    // 0x50: MOV AC, #10 result
0000    // 0x51: MOV X, #20 result
0000    // 0x52: MOV Y, #30 result
0000    // 0x53: MOV X, AC result = 15
0000    // 0x54: MOV Y, X result = 15
0000    // 0x55: ADD AC, X result = 15
0000    // 0x56: SUB AC, X result = 10
0000    // 0x57: ADD AC, #7 result = 17
0000    // 0x58: SUB AC, #3 result = 14
0000    // 0x59: MUL AC, X result = 15
0000    // 0x5A: DIV AC, X result = 6
0000    // 0x5B: MOD AC, X result = 0
0000    // 0x5C: AND AC, X result = 7
0000    // 0x5D: OR AC, X result = 15
0000    // 0x5E: XOR AC, X result = 15
0000    // 0x5F: NOT X result = 0xFFF8
0000    // 0x60: LSR result = 8
0000    // 0x61: LSL result = 16
0000    // 0x62: RSR result = 0x50
0000    // 0x63: RSL result = 0x0A
0000    // 0x64: CMP marker = 1
0000    // 0x65: TST marker = 2
