/// 1. First Program
0407 // 0000 0100 0000 0110 (X = Mem(address))
0A08 // 0000 1010 0000 0111  (ACC = Mem(Y + offset)) Y=0 
1409 // 0001 0100 0000 1000   (ACC = Mem(address))
0C0A // 0000 1100 0000 1001 (Mem(address) = X)
120B // 0001 0010 0000 1010  (Mem(Y + offset) = ACC)
180C // 0001 1000 0000 1011   (Mem(address) = ACC)


/// 2. Second Program
040A // 0000 0100 0000 0110  X = Mem(address)
0A0B // 0000 1010 0000 0111  ACC = Mem(Y + offset) Y=0 
140C // 0001 0100 0000 1000  ACC = Mem(address)
0C0D // 0000 1100 0000 1001  Mem(address) = X
120E // 0001 0010 0000 1010  Mem(Y + offset) = ACC
060F // 0000 0110 0000 0110  Y = Mem(address)
1810 // 0001 1000 0000 1011  Mem(address) = ACC
0411 // 0000 0100 0000 0110  X = Mem(address)
0412 // 0000 0100 0000 0110  Y = Mem(address)
0C0D // 0000 1110 0000 1001  Mem(address) = Y
0000
1234
1235
1236
1237
1238
1239
1240
1241
1242
1243

/// 3. Memory Program 
// =========================================================================
// TEST PROGRAM - PUSH, POP, INP, OUT + instructiuni de baza
// =========================================================================
// SP initial = 0x01FF (stack creste in jos)
// Format PUSH/POP/INP/OUT: opcode[15:10], imm[9:0]
// imm[9:4] = 000000, imm[3:0] = reg_code (0=PC, 1=AC, 2=X, 3=Y)
// =========================================================================

// --- SECTIUNEA 1: Incarca valori initiale ---
0430 // 0x00: LDR X, #30      -> X = Mem[30] = 0002
0631 // 0x01: LDR Y, #31      -> Y = Mem[31] = 0003
1432 // 0x02: LDA AC, #32     -> AC = Mem[32] = 1234

// --- SECTIUNEA 2: Test PUSH ---
1C01 // 0x03: PUSH AC         -> Mem[SP] = AC = 1234, SP--  (SP: 1FF->1FE)
1C02 // 0x04: PUSH X          -> Mem[SP] = X = 0002, SP--   (SP: 1FE->1FD)
1C03 // 0x05: PUSH Y          -> Mem[SP] = Y = 0003, SP--   (SP: 1FD->1FC)

// --- SECTIUNEA 3: Schimba valorile registrelor ---
0433 // 0x06: LDR X, #33      -> X = Mem[33] = AAAA (valoare noua)
0634 // 0x07: LDR Y, #34      -> Y = Mem[34] = BBBB (valoare noua)
1435 // 0x08: LDA AC, #35     -> AC = Mem[35] = CCCC (valoare noua)

// --- SECTIUNEA 4: Test POP (ordine inversa) ---
2003 // 0x09: POP Y           -> SP++, Y = Mem[SP] = 0003   (SP: 1FC->1FD)
2002 // 0x0A: POP X           -> SP++, X = Mem[SP] = 0002   (SP: 1FD->1FE)
2001 // 0x0B: POP AC          -> SP++, AC = Mem[SP] = 1234  (SP: 1FE->1FF)

// --- SECTIUNEA 5: Store pentru verificare POP ---
0C36 // 0x0C: STR X, #36      -> Mem[36] = X = 0002
0E37 // 0x0D: STR Y, #37      -> Mem[37] = Y = 0003
1838 // 0x0E: STA #38         -> Mem[38] = AC = 1234

// --- SECTIUNEA 6: Test INP/OUT ---
2401 // 0x0F: INP AC          -> AC = input de la tastatura
1839 // 0x10: STA #39         -> Mem[39] = AC (valoare citita)
2402 // 0x11: INP X           -> X = input de la tastatura
0C3A // 0x12: STR X, #3A      -> Mem[3A] = X (valoare citita)
2801 // 0x13: OUT AC          -> Afiseaza AC
2802 // 0x14: OUT X           -> Afiseaza X

// --- SECTIUNEA 7: HLT ---
0000 // 0x15: HLT             -> Stop

// --- PADDING ---
0000 // 0x16
0000 // 0x17
0000 // 0x18
0000 // 0x19
0000 // 0x1A
0000 // 0x1B
0000 // 0x1C
0000 // 0x1D
0000 // 0x1E
0000 // 0x1F
0000 // 0x20
0000 // 0x21
0000 // 0x22
0000 // 0x23
0000 // 0x24
0000 // 0x25
0000 // 0x26
0000 // 0x27
0000 // 0x28
0000 // 0x29
0000 // 0x2A
0000 // 0x2B
0000 // 0x2C
0000 // 0x2D
0000 // 0x2E
0000 // 0x2F

// --- DATA SECTION (0x30-0x3F) ---
0002 // 0x30: valoare initiala X
0003 // 0x31: valoare initiala Y
1234 // 0x32: valoare initiala AC
AAAA // 0x33: valoare noua X (dupa PUSH, inainte POP)
BBBB // 0x34: valoare noua Y (dupa PUSH, inainte POP)
CCCC // 0x35: valoare noua AC (dupa PUSH, inainte POP)
0000 // 0x36: pentru verificare X dupa POP
0000 // 0x37: pentru verificare Y dupa POP
0000 // 0x38: pentru verificare AC dupa POP
0000 // 0x39: pentru valoare INP AC
0000 // 0x3A: pentru valoare INP X

/// 4. Memory + Branch Instructions Program
// =========================================================================
// TEST PROGRAM - Toate instructiunile implementate
// =========================================================================
// SP initial = 0x200 (512), stack creste in jos
// Memoria: 512 adrese (9 biti), adrese 0x000 - 0x1FF
// =========================================================================

// ==========================================================================
// SECTIUNEA 1: Test LDR, LDA_IMM, STR, STA_IMM (instructiuni de baza)
// ==========================================================================
0430    // 0x00: LDR X, #30         -> X = Mem[0x30] = 0x000A (10)
0631    // 0x01: LDR Y, #31         -> Y = Mem[0x31] = 0x0014 (20)
1432    // 0x02: LDA_IMM #32        -> AC = Mem[0x32] = 0x001E (30)

// ==========================================================================
// SECTIUNEA 2: Test PUSH/POP
// ==========================================================================
1C01    // 0x03: PUSH AC            -> Mem[0x1FF] = AC = 0x001E, SP = 0x1FE
1C02    // 0x04: PUSH X             -> Mem[0x1FE] = X = 0x000A, SP = 0x1FD
1C03    // 0x05: PUSH Y             -> Mem[0x1FD] = Y = 0x0014, SP = 0x1FC

0433    // 0x06: LDR X, #33         -> X = Mem[0x33] = 0xAAAA (schimba valori)
0634    // 0x07: LDR Y, #34         -> Y = Mem[0x34] = 0xBBBB
1435    // 0x08: LDA_IMM #35        -> AC = Mem[0x35] = 0xCCCC

2003    // 0x09: POP Y              -> SP = 0x1FD, Y = Mem[0x1FD] = 0x0014
2002    // 0x0A: POP X              -> SP = 0x1FE, X = Mem[0x1FE] = 0x000A
2001    // 0x0B: POP AC             -> SP = 0x1FF, AC = Mem[0x1FF] = 0x001E

// Store rezultate POP pentru verificare
0C40    // 0x0C: STR X, #40         -> Mem[0x40] = X = 0x000A
0E41    // 0x0D: STR Y, #41         -> Mem[0x41] = Y = 0x0014
1842    // 0x0E: STA_IMM #42        -> Mem[0x42] = AC = 0x001E

// ==========================================================================
// SECTIUNEA 3: Test JMP si RET
// ==========================================================================
// JMP salveaza PC+1 pe stack si sare la adresa
// RET restaureaza PC de pe stack

4820    // 0x0F: JMP 0x20           -> PUSH PC+1 (0x10), PC = 0x20 (subroutine)
        // Dupa RET, executia continua de la 0x10

// Dupa return din subroutine:
0C43    // 0x10: STR X, #43         -> Mem[0x43] = X = 0x0055 (setat in subroutine)
0E44    // 0x11: STR Y, #44         -> Mem[0x44] = Y = 0x00AA (setat in subroutine)

// ==========================================================================
// SECTIUNEA 4: Test BRA (branch always)
// ==========================================================================
4415    // 0x12: BRA 0x15           -> PC = 0x15 (sare peste 0x13, 0x14)

// Aceste instructiuni NU ar trebui executate (sarite de BRA)
0436    // 0x13: LDR X, #36         -> X = 0xDEAD (NU se executa)
0637    // 0x14: LDR Y, #37         -> Y = 0xBEEF (NU se executa)

// Continuare dupa BRA
1845    // 0x15: STA_IMM #45        -> Mem[0x45] = AC = 0x001E (verifica BRA a sarit)

// ==========================================================================
// SECTIUNEA 5: Test Conditional Branches (BNE, BEQ, etc.)
// ==========================================================================
// Nota: Flag-urile sunt probabil 0 dupa reset (Z=0, N=0, V=0, C=0)
// BNE (Z=0) ar trebui sa fie TAKEN
// BEQ (Z=1) ar trebui sa fie NOT TAKEN

3019    // 0x16: BNE 0x19           -> Z=0, deci branch TAKEN, PC = 0x19

// Aceste instructiuni NU ar trebui executate (sarite de BNE)
0436    // 0x17: LDR X, #36         -> X = 0xDEAD (NU se executa)
0637    // 0x18: LDR Y, #37         -> Y = 0xBEEF (NU se executa)

// Continuare dupa BNE
1846    // 0x19: STA_IMM #46        -> Mem[0x46] = AC (verifica BNE a sarit)

// Test BEQ - ar trebui sa NU fie luat (Z=0)
2C1C    // 0x1A: BEQ 0x1C           -> Z=0, deci branch NOT TAKEN, continua la 0x1B

1847    // 0x1B: STA_IMM #47        -> Mem[0x47] = AC (verifica BEQ NU a sarit)

// ==========================================================================
// SECTIUNEA 6: HLT
// ==========================================================================
0000    // 0x1C: HLT                -> Stop

// ==========================================================================
// PADDING (0x1D - 0x1F)
// ==========================================================================
0000    // 0x1D
0000    // 0x1E
0000    // 0x1F

// ==========================================================================
// SUBROUTINE la adresa 0x20 (apelata de JMP)
// ==========================================================================
0438    // 0x20: LDR X, #38         -> X = Mem[0x38] = 0x0055
0639    // 0x21: LDR Y, #39         -> Y = Mem[0x39] = 0x00AA
4C00    // 0x22: RET                -> POP PC, revine la 0x10

// ==========================================================================
// PADDING (0x23 - 0x2F)
// ==========================================================================
0000    // 0x23
0000    // 0x24
0000    // 0x25
0000    // 0x26
0000    // 0x27
0000    // 0x28
0000    // 0x29
0000    // 0x2A
0000    // 0x2B
0000    // 0x2C
0000    // 0x2D
0000    // 0x2E
0000    // 0x2F

// ==========================================================================
// DATA SECTION (0x30 - 0x4F)
// ==========================================================================
000A    // 0x30: valoare initiala X = 10
0014    // 0x31: valoare initiala Y = 20
001E    // 0x32: valoare initiala AC = 30
AAAA    // 0x33: valoare temporara X
BBBB    // 0x34: valoare temporara Y
CCCC    // 0x35: valoare temporara AC
DEAD    // 0x36: valoare "bad" X (nu ar trebui citita)
BEEF    // 0x37: valoare "bad" Y (nu ar trebui citita)
0055    // 0x38: valoare subroutine X
00AA    // 0x39: valoare subroutine Y
0000    // 0x3A
0000    // 0x3B
0000    // 0x3C
0000    // 0x3D
0000    // 0x3E
0000    // 0x3F

// Zona pentru rezultate verificare (0x40 - 0x4F)
0000    // 0x40: rezultat POP X
0000    // 0x41: rezultat POP Y
0000    // 0x42: rezultat POP AC
0000    // 0x43: rezultat subroutine X
0000    // 0x44: rezultat subroutine Y
0000    // 0x45: marker BRA executat
0000    // 0x46: marker BNE executat
0000    // 0x47: marker BEQ NOT taken


/// 4
// =========================================================================
// COMPREHENSIVE TEST PROGRAM - ALL INSTRUCTIONS
// =========================================================================
// SP initial = 0x200 (512), memoria: 512 adrese (9 biti)
// =========================================================================

// ==========================================================================
// SECTIUNEA 1: Test MOV (Load initial values using MOV)
// ==========================================================================
B44A    // 0x00: MOV X, #10         -> X = 10 (0x000A)
B494    // 0x01: MOV Y, #20         -> Y = 20 (0x0014)
B41E    // 0x02: MOV AC, #30        -> AC = 30 (0x001E)
0C50    // 0x03: STR X, #50         -> Mem[50] = X = 0x000A
0E51    // 0x04: STR Y, #51         -> Mem[51] = Y = 0x0014
1852    // 0x05: STA #52            -> Mem[52] = AC = 0x001E

// ==========================================================================
// SECTIUNEA 2: Test ARITHMETIC (Reg) - ADD, SUB, MUL, DIV, MOD
// ==========================================================================
// AC = 30 (0x1E), X = 10, Y = 20

5000    // 0x06: ADD AC, X          -> AC = AC + X = 30 + 10 = 40 (0x28)
1853    // 0x07: STA #53            -> Mem[53] = 40

5500    // 0x08: SUB AC, X          -> AC = AC - X = 40 - 10 = 30 (0x1E)
1854    // 0x09: STA #54            -> Mem[54] = 30

5105    // 0x0A: ADD AC, #5         -> AC = AC + 5 = 30 + 5 = 35 (0x23)
1855    // 0x0B: STA #55            -> Mem[55] = 35

5902    // 0x0C: SUB AC, #2         -> AC = AC - 2 = 35 - 2 = 33 (0x21)
1856    // 0x0D: STA #56            -> Mem[56] = 33

B403    // 0x0E: MOV AC, #3         -> AC = 3
5A00    // 0x0F: MUL AC, X          -> AC = AC * X = 3 * 10 = 30 (0x1E)
1857    // 0x10: STA #57            -> Mem[57] = 30

B428    // 0x11: MOV AC, #40        -> AC = 40
5E00    // 0x12: DIV AC, X          -> AC = AC / X = 40 / 10 = 4
1858    // 0x13: STA #58            -> Mem[58] = 4

B417    // 0x14: MOV AC, #23        -> AC = 23
6200    // 0x15: MOD AC, X          -> AC = AC % X = 23 % 10 = 3
1859    // 0x16: STA #59            -> Mem[59] = 3

// ==========================================================================
// SECTIUNEA 3: Test LOGIC (Reg) - AND, OR, XOR, NOT
// ==========================================================================
B40F    // 0x17: MOV AC, #15        -> AC = 0x0F (00001111)
B407    // 0x18: MOV X, #7          -> X = 0x07 (00000111)

6600    // 0x19: AND AC, X          -> AC = AC & X = 0x0F & 0x07 = 0x07
185A    // 0x1A: STA #5A            -> Mem[5A] = 0x07

B40F    // 0x1B: MOV AC, #15        -> AC = 0x0F
6A00    // 0x1C: OR AC, X           -> AC = AC | X = 0x0F | 0x07 = 0x0F
185B    // 0x1D: STA #5B            -> Mem[5B] = 0x0F

B408    // 0x1E: MOV AC, #8         -> AC = 0x08
6E00    // 0x1F: XOR AC, X          -> AC = AC ^ X = 0x08 ^ 0x07 = 0x0F
185C    // 0x20: STA #5C            -> Mem[5C] = 0x0F

7000    // 0x21: NOT X              -> AC = ~X = ~0x07 = 0xFFF8
185D    // 0x22: STA #5D            -> Mem[5D] = 0xFFF8

// ==========================================================================
// SECTIUNEA 4: Test ARITHMETIC (Memory) - ADD_M, SUB_M
// ==========================================================================
B40A    // 0x23: MOV AC, #10        -> AC = 10
7460    // 0x24: ADD_M #60          -> AC = AC + Mem[60] = 10 + 5 = 15
185E    // 0x25: STA #5E            -> Mem[5E] = 15

B414    // 0x26: MOV AC, #20        -> AC = 20
7860    // 0x27: SUB_M #60          -> AC = AC - Mem[60] = 20 - 5 = 15
185F    // 0x28: STA #5F            -> Mem[5F] = 15

// ==========================================================================
// SECTIUNEA 5: Test SHIFTS - LSR, LSL, RSR, RSL
// ==========================================================================
B410    // 0x29: MOV AC, #16        -> AC = 16 (0x10)
9801    // 0x2A: LSR #1             -> AC = AC >> 1 = 16 >> 1 = 8
1860    // 0x2B: STA #60            -> Mem[60] = 8 (overwrite old value)

B404    // 0x2C: MOV AC, #4         -> AC = 4
9C02    // 0x2D: LSL #2             -> AC = AC << 2 = 4 << 2 = 16
1861    // 0x2E: STA #61            -> Mem[61] = 16

B4A0    // 0x2F: MOV AC, #160       -> AC = 0x00A0 (10100000)
A000    // 0x30: RSR                -> AC rotate right 1 = 0x0050 (01010000)
1862    // 0x31: STA #62            -> Mem[62] = 0x50

B405    // 0x32: MOV AC, #5         -> AC = 0x0005 (00000101)
A400    // 0x33: RSL                -> AC rotate left 1 = 0x000A (00001010)
1863    // 0x34: STA #63            -> Mem[63] = 0x0A

// ==========================================================================
// SECTIUNEA 6: Test CMP/TST and conditional branches
// ==========================================================================
B40A    // 0x35: MOV AC, #10        -> AC = 10
B40A    // 0x36: MOV X, #10         -> X = 10
A801    // 0x37: CMP AC, X          -> AC - X = 0, Z=1

2C3A    // 0x38: BEQ 0x3A           -> Z=1, TAKEN -> PC = 0x3A
0464    // 0x39: LDR X, #64         -> NU se executa (skip)

// Continuare dupa BEQ (0x3A)
B401    // 0x3A: MOV AC, #1         -> AC = 1 (marker BEQ taken)
1864    // 0x3B: STA #64            -> Mem[64] = 1

B40F    // 0x3C: MOV AC, #15        -> AC = 15
B405    // 0x3D: MOV X, #5          -> X = 5
A801    // 0x3E: CMP AC, X          -> AC - X = 10 > 0, Z=0, N=0, V=0 (N==V)

3440    // 0x3F: BGT 0x40           -> BGT TAKEN -> PC = 0x40

// Continuare dupa BGT (0x40)
B402    // 0x40: MOV AC, #2         -> AC = 2 (marker BGT taken)
1865    // 0x41: STA #65            -> Mem[65] = 2

// ==========================================================================
// SECTIUNEA 7: Test MOV Reg, Reg
// ==========================================================================
B40A    // 0x43: MOV AC, #10        -> AC = 10
B020    // 0x44: MOV X, AC          -> X = AC = 10
B041    // 0x45: MOV Y, X           -> Y = X = 10
0E66    // 0x46: STR Y, #66         -> Mem[66] = Y = 10

// ==========================================================================
// SECTIUNEA 8: Test JMP/RET (verify stack operations work with ALU)
// ==========================================================================
486E    // 0x47: JMP 0x6E           -> PUSH PC+1 (0x48), jump to subroutine

// Return point after subroutine
0C67    // 0x48: STR X, #67         -> Mem[67] = X (set in subroutine)
0E68    // 0x49: STR Y, #68         -> Mem[68] = Y (set in subroutine)

// ==========================================================================
// SECTIUNEA 9: HLT
// ==========================================================================
0000    // 0x4A: HLT                -> Stop

// ==========================================================================
// PADDING (0x4B - 0x4F)
// ==========================================================================
0000    // 0x4B
0000    // 0x4C
0000    // 0x4D
0000    // 0x4E
0000    // 0x4F

// ==========================================================================
// DATA SECTION (0x50 - 0x6F)
// ==========================================================================
0000    // 0x50: space for STR X result
0000    // 0x51: space for STR Y result
0000    // 0x52: space for STA AC result
0000    // 0x53: ADD AC, X result = 40
0000    // 0x54: SUB AC, X result = 30
0000    // 0x55: ADD AC, #5 result = 35
0000    // 0x56: SUB AC, #2 result = 33
0000    // 0x57: MUL AC, X result = 30
0000    // 0x58: DIV AC, X result = 4
0000    // 0x59: MOD AC, X result = 3
0000    // 0x5A: AND AC, X result = 7
0000    // 0x5B: OR AC, X result = 15
0000    // 0x5C: XOR AC, X result = 15
0000    // 0x5D: NOT X result = 0xFFF8
0000    // 0x5E: ADD_M result = 15
0000    // 0x5F: SUB_M result = 15
0005    // 0x60: data for memory operations (5, overwritten by LSR = 8)
0000    // 0x61: LSL result = 16
0000    // 0x62: RSR result = 0x50
0000    // 0x63: RSL result = 0x0A
0000    // 0x64: BEQ marker = 1
0000    // 0x65: BGT marker = 2
0000    // 0x66: MOV Y,X result = 10
0000    // 0x67: subroutine X result
0000    // 0x68: subroutine Y result
0000    // 0x69
0000    // 0x6A
0000    // 0x6B
0000    // 0x6C
0000    // 0x6D

// ==========================================================================
// SUBROUTINE at 0x6E (called by JMP)
// ==========================================================================
B432    // 0x6E: MOV X, #50         -> X = 50 (0x32)
B464    // 0x6F: MOV Y, #100        -> Y = 100 (0x64)
4C00    // 0x70: RET                -> POP PC, return to 0x48
